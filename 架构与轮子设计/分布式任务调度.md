
## 一、master任务分配模式
选举一台机器作为master，master除了需要处理任务之外，赋予额外的能力，比如检测活跃机器，然后根据分配策略分配任务以及失败，超时任务重新调度等能力。

### 1.1 架构设计

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/4bf4dff0aadd06eb1e3a2008715b97d5.png)


### 1.2 模块设计

#### 1.2.1 master选举

master选举采用最简单的实现方式，就是抢占分布式锁，master选举成功之后，任务的切分由用户通过SPI实现，该组件可单独用于master选举，但依然要注意机器假死产生的脑裂问题。出现脑裂问题时，问题机器应该拥有快速检测到自己与外部网络不通的问题，或者给定下一个需要当选master机器一个等待时间，确保老的master做了退选操作，代价是这段时间，机器不可用，相当于CAP理论中取了CP。另外如果要更加有效的解决这类问题，那么就不能依赖其他的分布式组件，采用paxos分布式一致性协议去实现master的选举。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/7585f3a61feb22fe8caa26eb37d12609.png)


#### 1.2.2 任务分配

当选举出一个master之后，我们需要进行任务的分配，分配方式可以有很多种，比如循环分配，范围分配，根据各机器资源情况分配等等，只要你能想到的，都可以去实现，配置好即可

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/56558f623aab95535895f90d0bf0b809.png)


思考：将任务分配更改为mq会怎样？
1、使用mq相当于借用mq的任务分配能力，简化开发难度，与master主动分配相比，mq是在消费者端根据分配策略进行分配，从长远看master分配方式更胜一筹，因为它能够根据各个机器的资源使用情况进行有目的性分配
2、mq主要作用是用来削峰填谷的，如果仅仅是用来实现任务分配，有种杀鸡用牛刀的感觉，不仅消耗了硬件资源还要增加维护成本

#### 1.2.3 MapReduce（取决于任务类型，比如 打点分析统计）

map过程属于将任务分配给各个机器之后，各个机器进行数据处理

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/f39d8bc61bd15ff16239eeaffcabdfa3.png)


reduce过程，通常出现在任务由一大块整体被切分为一个个小任务的情况，在处理完各小块任务之后需要对数据进行reduce。任务切分可以使用 master 选举组件，实现选举master回调，用于任务切分。切分后自身根据业务特点提交reduce任务

#### 1.2.4 活跃检测

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/9072590127934da92ef08c278c66a505.png)


#### 1.2.5 任务重试

任务在执行当中，不可避免的可能出现执行失败的情况，失败的情况有很多种，比如任务本身执行失败，机器资源问题不够一直超时，机器的奔溃，重启，下线等等问题。

master 启动任务重试任务调度线程，扫描已经分配出去的任务，如果任务执行失败，重新扔到其他机器中执行，将任务状态重新修改为正在执行中，如果任务执行超时，那么将任务提交到其他机器中执行，将状态修改为正在执行中

每台机器重启时检查当前机器上次是否还有正在执行中或者即将执行成功状态的任务，如果有，将他们的任务状态修改为失败，让重试调度线程重新调度。

#### 1.2.6 历史任务迁移

master 对已经执行完的任务记录，将迁移到历史表中保存

## 二、任务抢占

任务抢占就是多台机器抢占相同列表的任务，举个例子：有一个水果摊，上面有各种类型的水果，它们是免费的，有三个人想要去抢夺这些水果，谁抢到就是谁的，翻译成图如下：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/159e961bc12c04416575345b24353c06.png)


任务抢占与master选举最大的不同点在于如何分配任务，其他的都是一样的，这里不再赘述。